## Легенда

Некий банк выполнил миграцию с одной БД на другую. В ходе миграции были частично сломаны некоторые ETL-процессы и частично утеряны некоторые данные. Вам предстоит это исправить.

## Перечень технологий:

- Реляционная СУБД: PostgreSQL 13+;
- Среда SQL разработки:  DBeaver;
- Python 3.10, Java 8;
- Ubuntu 19+;
- Spark / PySpark;
- Docker;
- Airflow 2 (Оркестрация процесса загрузки с помощью Airflow. Данный критерий не обязательный, но если вдруг вы сможете самостоятельно понять, установить и применить этот инструмент – это будет большим плюсом.);
- Jupyter notebook (опционально);
- Virtual Box (опционально);
## **Требования к демонстрации работы:**

- Все скрипты и решения необходимо опубликовать в  github и предоставить ссылку на репозиторий. В случае работы в Talend выгрузите и прикрепите поток.
- Записать видео с экрана компьютера, в котором вы демонстрируйте и комментируете в слух, то что вы делаете / уже разработали;
- Нужно продемонстрировать создание или подробно прокомментировать разработанный вами поток (ETL-процесс);
- Продемонстрировать, что поток работает – показать, что в таблице «DS.ft_balance_f» не было записей, потом запустить поток и показать, что таблица наполнилась;
- Запись в таблицы должна выполняться в режиме «Запись или замена». Поэтому не забудьте определить ключевые поля для возможности обновлять информацию по уже существующим записям;
- Продемонстрируйте как вы в файле «ft_balance_f.csv» меняете баланс для какого-нибудь <account_rk>, показываете что в таблице «DS.ft_balance_f» сперва была одна сумма у этого <account_rk> - потом запускаете ETL-процесс и показываете, что в таблице сумма обновилась;
- Это видео загрузите к себе на облако (гугл-диск, яндекс-диск и т.п.) и предоставьте доступ по ссылке;
- Приложите в репозиторий github текстовый файл с ссылкой на ваше видео
# **Задание №1**

В некотором банке внедрили новую frontend-систему для работы с клиентами, а так же обновили и саму базу данных. Большую часть данных успешно были перенесены из старых БД в одну новую централизованную БД.  Но в момент переключения со старой системы на новую возникли непредвиденные проблемы в ETL-процессе, небольшой период (конец 2017 начало 2018 года) так и остался в старой базе. Старую базу отключили, а не выгруженные данные сохранили в csv-файлы. Недавно банку потребовалось построить отчёт по 101 форме. Те данные что остались в csv-файлах тоже нужны. Загрузить их в новую БД не получиться из-за архитектурных и управленческих сложностей, нужно рассчитать витрину отдельно. Но для этого сначала нужно загрузить исходные данные из csv-файлов в детальный слой (DS) хранилища в СУБД PostgreSQL.

## Таблицы в БД
### Слой детальных данных DS

#### DS.FT_BALANCE_F

| Column Name      | Data Type       |
|------------------|-----------------|
| on_date          | DATE not null  |
| account_rk       | NUMBER not null |
| currency_rk      | NUMBER          |
| balance_out      | FLOAT           |
#### DS.FT_POSTING_F

| Column Name          | Data Type       |
|----------------------|-----------------|
| oper_date            | DATE not null  |
| credit_account_rk    | NUMBER not null |
| debet_account_rk     | NUMBER not null |
| credit_amount        | FLOAT           |
| debet_amount         | FLOAT           |
#### DS.MD_ACCOUNT_D

| Column Name            | Data Type                     |
|------------------------|-------------------------------|
| data_actual_date       | DATE not null                 |
| data_actual_end_date   | DATE not null                 |
| account_rk             | NUMBER not null               |
| account_number         | VARCHAR2(20 char) not null    |
| char_type              | VARCHAR2(1 char) not null     |
| currency_rk            | NUMBER not null               |
| currency_code          | VARCHAR2(3 char) not null     |
#### DS.MD_CURRENCY_D

| Column Name            | Data Type                     |
|------------------------|-------------------------------|
| currency_rk            | NUMBER not null               |
| data_actual_date       | DATE not null                 |
| data_actual_end_date   | DATE                          |
| currency_code          | VARCHAR2(3 char)              |
| code_iso_char          | VARCHAR2(3 char)              |

#### DS.MD_EXCHANGE_RATE_D

| Column Name            | Data Type                     |
|------------------------|-------------------------------|
| data_actual_date       | DATE not null                 |
| data_actual_end_date   | DATE                          |
| currency_rk            | NUMBER not null               |
| reduced_cource         | FLOAT                         |
| code_iso_num           | VARCHAR2(3 char)              |

#### DS.MD_LEDGER_ACCOUNT_S

| Column Name                        | Data Type                     |
|------------------------------------|-------------------------------|
| chapter                            | CHAR(1 char)                  |
| chapter_name                       | VARCHAR2(16 char)             |
| section_number                     | INTEGER                       |
| section_name                       | VARCHAR2(22 char)             |
| subsection_name                    | VARCHAR2(21 char)             |
| ledger1_account                    | INTEGER                       |
| ledger1_account_name               | VARCHAR2(47 char)             |
| ledger_account                     | INTEGER not null              |
| ledger_account_name                | VARCHAR2(153 char)            |
| characteristic                     | CHAR(1 char)                  |
| is_resident                        | INTEGER                       |
| is_reserve                         | INTEGER                       |
| is_reserved                        | INTEGER                       |
| is_loan                            | INTEGER                       |
| is_reserved_assets                 | INTEGER                       |
| is_overdue                         | INTEGER                       |
| is_interest                        | INTEGER                       |
| pair_account                       | VARCHAR2(5 char)              |
| start_date                         | DATE not null                 |
| end_date                           | DATE                          |
| is_rub_only                        | INTEGER                       |
| min_term                           | VARCHAR2(1 char)              |
| min_term_measure                   | VARCHAR2(1 char)              |
| max_term                           | VARCHAR2(1 char)              |
| max_term_measure                   | VARCHAR2(1 char)              |
| ledger_acc_full_name_translit      | VARCHAR2(1 char)              |
| is_revaluation                     | VARCHAR2(1 char)              |
| is_correct                         | VARCHAR2(1 char)              |

### Слой витрин DM

#### DM.DM_ACCOUNT_TURNOVER_F

| Column Name            | Data Type                     |
|------------------------|-------------------------------|
| on_date                | DATE                          |
| account_rk             | NUMBER                        |
| credit_amount          | NUMBER(23,8)                 |
| credit_amount_rub      | NUMBER(23,8)                 |
| debet_amount           | NUMBER(23,8)                 |
| debet_amount_rub       | NUMBER(23,8)                 |

#### DM.DM_F101_ROUND_F

| Column Name        | Data Type    |
| ------------------ | ------------ |
| FROM_DATE          | DATE         |
| TO_DATE            | DATE         |
| CHAPTER            | CHAR(1 CHAR) |
| LEDGER_ACCOUNT     | CHAR(5 CHAR) |
| CHARACTERISTIC     | CHAR(1 CHAR) |
| BALANCE_IN_RUB     | NUMBER(23,8) |
| R_BALANCE_IN_RUB   | NUMBER(23,8) |
| BALANCE_IN_VAL     | NUMBER(23,8) |
| R_BALANCE_IN_VAL   | NUMBER(23,8) |
| BALANCE_IN_TOTAL   | NUMBER(23,8) |
| R_BALANCE_IN_TOTAL | NUMBER(23,8) |
| TURN_DEB_RUB       | NUMBER(23,8) |
| R_TURN_DEB_RUB     | NUMBER(23,8) |
| TURN_DEB_VAL       | NUMBER(23,8) |
| R_TURN_DEB_VAL     | NUMBER(23,8) |
| TURN_DEB_TOTAL     | NUMBER(23,8) |
| R_TURN_DEB_TOTAL   | NUMBER(23,8) |
| TURN_CRE_RUB       | NUMBER(23,8) |
| R_TURN_CRE_RUB     | NUMBER(23,8) |
| TURN_CRE_VAL       | NUMBER(23,8) |
| R_TURN_CRE_VAL     | NUMBER(23,8) |
| TURN_CRE_TOTAL     | NUMBER(23,8) |
| R_TURN_CRE_TOTAL   | NUMBER(23,8) |
| BALANCE_OUT_RUB    | NUMBER(23,8) |
| R_BALANCE_OUT_RUB  | NUMBER(23,8) |
| BALANCE_OUT_VAL    | NUMBER(23,8) |
| R_BALANCE_OUT_VAL  | NUMBER(23,8) |
| BALANCE_OUT_TOTAL  | NUMBER(23,8) |

## **Задача 1.1** Детальный слой (DS) 

Разработать ETL-процесс для загрузки «банковских» данных из csv-файлов в соответствующие таблицы СУБД PostgreSQL. Покрыть данный процесс логированием этапов работы и всевозможной дополнительной статистикой (на ваше усмотрение). Обратите внимание, что в разных файлах может быть разный формат даты, это необходимо учитывать при загрузке.

**Краткое описание данных таблиц:**

Таблицы DS.MD_ACCOUNT_D, DS.MD_CURRENCY_D и DS.MD_EXCHANGE_RATE_D содержат информацию о счетах, валютах и курсах валют соответственно. В данных таблицах есть поля data_actual_date и data_actual_end_date, по которым можно определить какие именно записи актуальны в нужную дату. Идентификаторы записей имеют окончание «_rk» (например, account_rk – идентификатор счета).

Таблица DS.MD_LEDGER_ACCOUNT_S – это справочник балансовых счетов. Он регулируется Центральным банком. По нему можно определить к какой главе и к каким разделам относятся счета первого (первые 3 цифры номера счета) и второго (первые 5 цифр номера счета) порядка.

Таблица DS.FT_POSTING_F – это таблица проводок (операций) в рабочем дне (поле oper_date), которая состоит из двух частей: счет дебета и счет кредита, которая изменяет баланс на сумму проводки

#### **Требования к реализации задачи:**

- В своей БД создать пользователя / схему «DS».  
    Примеры команд:  
    [https://postgrespro.ru/docs/postgresql/9.6/sql-createschema](https://postgrespro.ru/docs/postgresql/9.6/sql-createschema)
- Создать в DS-схеме таблицы под загрузку данных из csv-файлов.
- Для хранения логов нужно в БД создать отдельного пользователя / схему «LOGS» и создать в этой схеме таблицу для логов;
- Начало и окончание работы процесса загрузки данных должно логироваться в специальную логовую таблицу. Эту таблицу нужно придумать самостоятельно. По логам должно быть видно дату и время старта и окончания загрузки, так же можете туда добавить любую дополнительную информацию, которую посчитаете нужным.
- После логирования о начале загрузки добавить таймер (паузу) на 5 секунд, чтобы чётко видеть разницу во времени между началом и окончанием загрузки. Из-за небольшого учебного объёма данных – процесс загрузки быстрый;
- Для корректного обновления данных в таблицах детального слоя DS нужно выбрать правильную Update strategy и использовать следующие первичные ключи для таблиц фактов, измерений и справочников (должно быть однозначное уникальное значение, идентифицирующее каждую запись таблицы):

| **Таблица**            | **Первичный ключ**                                                                                                                                                   |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| DS.FT_BALANCE_F        | ON_DATE, ACCOUNT_RK                                                                                                                                                  |
| DS.FT_POSTING_F        | У данной таблицы нет первичного ключа. Можно считать, что мы всегда в нее будем загружать полный набор данных, поэтому перед каждой загрузкой ее необходимо очищать. |
| DS.MD_ACCOUNT_D        | DATA_ACTUAL_DATE, ACCOUNT_RK                                                                                                                                         |
| DS.MD_CURRENCY_D       | CURRENCY_RK, DATA_ACTUAL_DATE                                                                                                                                        |
| DS.MD_EXCHANGE_RATE_D  | DATA_ACTUAL_DATE, CURRENCY_RK                                                                                                                                        |
| DS.MD_LEDGER_ACCOUNT_S | LEDGER_ACCOUNT, START_DATE                                                                                                                                           |

## **Задача 1.2**

После того как детальный слой «DS» успешно наполнен исходными данными из файлов – нужно рассчитать витрины данных в слое «DM»: витрину оборотов (DM.DM_ACCOUNT_TURNOVER_F) и витрину остатков (DM.DM_ACCOUNT_BALANCE_F). Структура и описание этих витрин находится в файле «Структура таблиц.docx». Вам необходимо их создать.
### ds.fill_account_turnover_f
Начнем с витрины оборотов по лицевым счетам. Данная витрина содержит информацию по оборотам по лицевым счетам в рамках дня, когда были обороты. Вам будет необходимо создать процедуру расчета (назовите ее ds.fill_account_turnover_f), которая должна иметь один входной параметр – дату расчета (i_OnDate). Поля должны быть заполнены следующим образом:
- on_date мы заполняем датой, за которую производим расчет (i_OnDate);
- account_rk  - идентификатор счета, по которому были проводки в дату расчету;
- credit_amount – сумма проводок (поле DS.FT_POSTING_F.credit_amount) за дату расчета (DS.FT_POSTING_F.oper_date = i_OnDate), где счет участвовал как счет по кредиту (DS.FT_POSTING_F.credit_account_rk);
- credit_amount_rub – credit_amount из предыдущего пункта, умноженный на курс действующий за эту дату (курс хранится в поле ds.md_exchange_rate_d. reduced_cource). Если информации о курсе нет, то умножаем на единицу.
- поля debet_amount и debet_amount_rub заполняем аналогично полям credit_amount и credit_amount_rub, только необходимо отбирать проводки, где счет участвовал как счет по дебету (DS.FT_POSTING_F.debet_account_rk) и необходимо брать сумму из поля DS.FT_POSTING_F.debet_amount.

Если по счету не было проводок в дату расчета, то он не должен попадать в витрину в эту дату. После создания процедуры рассчитайте данную витрину за каждый день января 2018 года.

Так как остатки за день считаются на основе остатков за предыдущий день, вам необходимо заполнить витрину DM.DM_ACCOUNT_BALANCE_F за 31.12.2017 данными из DS.FT_BALANCE_F. Поля on_date, account_rk, balance_out заполняются один в один, поле balance_out_rub заполняем как balance_out, умноженный на курс действующий за 31.12.2017. Если информации о курсе нет, то умножаем на единицу.

### ds.fill_account_balance_f
Затем необходимо создать процедуру заполнения витрины остатков по лицевым счетам. Назовите ее ds.fill_account_balance_f.  Данная процедура должна иметь один входной параметр – дату расчета (i_OnDate). Алгоритм заполнения следующий: необходимо взять все счета, действующие за дату расчета (дата расчета лежит между датами актуальности записей в таблице DS.MD_ACCOUNT_D), для этих счетов рассчитываем balance_out по следующему алгоритму:

- для активных счетов (DS.MD_ACCOUNT_D.char_type = ‘А’): берем остаток в валюте счета за предыдущий день (если его нет, то считаем его равным 0), прибавляем к нему обороты по дебету в валюте счета (DM.DM_ACCOUNT_TURNOVER_F.debet_amount) и вычитаем обороты по кредиту в валюте счета  (DM.DM_ACCOUNT_TURNOVER_F.credit_amount) за этот день.
- для пассивных счетов (DS.MD_ACCOUNT_D.char_type = ‘П’): берем остаток в валюте счета за предыдущий день (если его нет, то считаем его равным 0), вычитаем из него обороты по дебету в валюте счета и прибавляем обороты по кредиту в валюте счета  за этот день.
- Поле balance_out_rub заполняем аналогично полю balance_out, но для расчета берем поля в рублях. Обратите внимание, что в какие-то дни по счету может не быть оборотов, но остаток по счету мы должны заполнить. После создания процедуры рассчитайте витрину остатков за каждый день января 2018 года.

В процедурах добавьте логирование на свое усмотрение. В качестве таблицы с логами можно использовать таблицу, созданную в задаче 1.1.  В логах должны быть информация о том какая витрина рассчитывается, дата и время старта и окончания расчета. Так же для возможности перезапускать расчет много раз за одни и те же даты, в процедурах в начале расчета вам необходимо удалять записи за дату расчета.

#### **Требования к демонстрации работы:**

- Все скрипты и решения необходимо опубликовать в  github и предоставить ссылку на репозиторий.
- Записать видео с экрана компьютера, в котором вы демонстрируйте и комментируете в слух, то что вы делаете / уже разработали;
- Нужно продемонстрировать, как вы запускаете расчёт ежедневной витрины оборотов и витрины остатков за весь месяц и то как в витринах постепенно начинают появляться данные за разные дни Января;
- Обязательно продемонстрируйте процесс логирования, который присутствует внутри процедур. Покажите, как при запуске расчёта витрины в логовой таблице появилась новая информация. Расскажите на видео почему выбрали именно такой вариант логирования.
- Это видео загрузите к себе на облако (гугл-диск, яндекс-диск и т.п.) и предоставьте доступ по ссылке;
- Приложите в репозиторий github текстовый файл с ссылкой на ваше видео


## Задача 1.3

После того как в предыдущих заданиях вы загрузили необходимую информацию и рассчитали витрины с оборотами и остатками, необходимо произвести расчет 101 формы за январь 2018 года. Структура и описание витрины по этой форме (DM.DM_F101_ROUND_F) находится в файле «Структура таблиц.docx». Вам необходимо ее создать.

101 форма содержит информацию об остатках и оборотах за отчетный период, сгруппированных по балансовым счетам второго порядка. Вам необходимо создать процедуру расчета (назовите ее dm.fill_f101_round_f), которая должна иметь один входной параметр – отчетную дату (i_OnDate). Отчетная дата – это первый день месяца, следующего за отчетным. То есть, если мы хотим рассчитать отчет за январь 2018 года, то должны передать в процедуру 1 февраля 2018 года. В отчет должна попасть информация по всем счетам, действующим в отчетном периоде, группировка в отчете идет по балансовым счетам второго порядка (балансовый счет второго порядка – это первые 5 символов номера счета (DS.MD_ACCOUNT_D.account_number). Поля витрины должны заполняться следующим образом:

FROM_DATE – первый день отчетного периода, TO_DATE – последний день отчетного периода;

CHAPTER – глава из справочника балансовых счетов (DS.MD_LEDGER_ACCOUNT_S);

LEDGER_ACCOUNT – балансовый счет второго порядка, CHARACTERISTIC – характеристика счета (можно получить из поля DS.MD_ACCOUNT_D.char_type);

BALANCE_IN_RUB – сумма остатков в рублях (DM.DM_ACCOUNT_BALANCE_F**.**balance_out_rub) за день, предшествующему первому дню отчетного периода (если отчет собирается за январь 2018 года, то это 31 декабря 2017 года), для рублевых счетов (рублевые счета, это те, у которых код валюты (поле DS.MD_ACCOUNT_D.currency_code равно 810 или 643));

BALANCE_IN_VAL – сумма остатков в рублях за день, предшествующему первому дню отчетного периода для всех счетов, кроме рублевых

BALANCE_IN_TOTAL - – сумма остатков в рублях за день, предшествующему первому дню отчетного периода для всех счетов;

TURN_DEB_RUB – сумма дебетовых оборотов в рублях (DM.DM_ACCOUNT_TURNOVER_F.debet_amount_rub) за все дни отчетного периода для рублевых счетов

TURN_DEB_VAL – сумма дебетовых оборотов в рублях за все дни отчетного периода для всех счетов, кроме рублевых;

TURN_DEB_TOTAL – сумма дебетовых оборотов в рублях за все дни отчетного периода для всех счетов

TURN_CRE_RUB – сумма кредитовых оборотов в рублях (DM.DM_ACCOUNT_TURNOVER_F.credit_amount_rub) за все дни отчетного периода для рублевых счетов;

TURN_CRE_VAL – сумма кредитовых оборотов в рублях за все дни отчетного периода для всех счетов, кроме рублевых;

TURN_CRE_TOTAL – сумма кредитовых оборотов в рублях за все дни отчетного периода для всех счетов

BALANCE_OUT_RUB – сумма остатков в рублях (DM.DM_ACCOUNT_BALANCE_F**.**balance_out_rub) за последний день отчетного периода для рублевых счетов;

BALANCE_OUT_VAL – сумма остатков в рублях за последний день отчетного периода для всех счетов, кроме рублевых;

BALANCE_OUT_TOTAL – сумма остатков в рублях за последний день отчетного периода для всех счетов

В процедуре расчета добавьте логирование на свое усмотрение. В качестве таблицы с логами можно использовать таблицу, созданную для предыдущих задач. В логах должна быть информация о том какая витрина рассчитывается, дата и время старта и окончания расчета. Так же для возможности перезапускать расчет много раз за одну и ту же дату, в процедурах в начале расчета вам необходимо удалять записи за дату расчета. Рассчитайте отчет за январь 2018 года.

## 1.4
Выполнив предыдущие 2 задачи вам удалось рассчитать отчётную форму 101. Менеджер проекта доволен, ЦБ получил отчёт, руководство банка тоже довольно. Теперь необходимо выгрузить эти данные в формате, который бы позволил легко обмениваться ими между отделами. Один из таких форматов – CSV.

Напишите скрипт, который позволит выгрузить данные из витрины «dm. dm _f101_round_f» в csv-файл, первой строкой должны быть наименования колонок таблицы.

Убедитесь, что данные выгружаются в корректном формате и напишите скрипт, который позволит импортировать их обратно в БД. Поменяйте пару значений в выгруженном csv-файле и загрузите его в копию таблицы 101-формы «dm. dm _f101_round_f_v2».

Постарайтесь покрыть данные процессы простым логированием. Скрипты можно написать на Python / Scala / Java.